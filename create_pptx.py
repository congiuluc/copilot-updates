#!/usr/bin/env python3
"""
Convert markdown article files (generated by the Copilot agent) into a PowerPoint presentation.

Usage:
    python create_pptx.py [--output OUTPUT.pptx] [--output-dir output/] [--locale en]

The script reads all .md files from output/{locale}/{new-releases,improvements,deprecations}/,
parses the YAML front matter and body content, and creates a .pptx with:
  - A title slide for the presentation
  - Section divider slides for each category
  - For each article: Slide 1 = title + image, Slide 2 = summary + speaker notes
"""

from __future__ import annotations

import argparse
import io
import re
import sys
from dataclasses import dataclass
from pathlib import Path

import requests
import yaml
from PIL import Image
from pptx import Presentation
from pptx.util import Inches, Pt, Emu
from pptx.enum.text import PP_ALIGN
from pptx.dml.color import RGBColor
from pptx.oxml.ns import qn


# â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Slide dimensions (widescreen 16:9)
SLIDE_WIDTH = Inches(13.333)
SLIDE_HEIGHT = Inches(7.5)

# Color palette (GitHub dark theme)
COLOR_BG_DARK = RGBColor(0x0D, 0x11, 0x17)
COLOR_ACCENT = RGBColor(0x58, 0xA6, 0xFF)
COLOR_TEXT_WHITE = RGBColor(0xFF, 0xFF, 0xFF)
COLOR_TEXT_LIGHT = RGBColor(0xC9, 0xD1, 0xD9)
COLOR_TEXT_MUTED = RGBColor(0x8B, 0x94, 0x9E)

# Per-section theming (single source of truth)
SECTION_META: dict[str, dict] = {
    "new-release": {
        "color": RGBColor(0x3F, 0xB9, 0x50),
        "emoji": "ğŸš€",
        "title": "New Releases",
        "dir": "new-releases",
    },
    "improvement": {
        "color": RGBColor(0x58, 0xA6, 0xFF),
        "emoji": "âœ¨",
        "title": "Improvements",
        "dir": "improvements",
    },
    "deprecation": {
        "color": RGBColor(0xF8, 0x54, 0x49),
        "emoji": "âš ï¸",
        "title": "Deprecations",
        "dir": "deprecations",
    },
}

SECTION_ORDER = ("new-release", "improvement", "deprecation")

# Front-matter type aliases â†’ canonical key
_TYPE_ALIASES: dict[str, str] = {
    "new-releases": "new-release",
    "new-release": "new-release",
    "release": "new-release",
    "improvements": "improvement",
    "improvement": "improvement",
    "deprecations": "deprecation",
    "deprecation": "deprecation",
    "retired": "deprecation",
}

SCRIPT_DIR = Path(__file__).resolve().parent
FALLBACK_IMAGES: dict[str, Path] = {
    key: SCRIPT_DIR / "imgs" / f"featured-v3-{meta['dir']}.png"
    for key, meta in SECTION_META.items()
}

PX_TO_EMU = 914400 // 96  # EMUs per pixel at 96 DPI


# â”€â”€ Data model â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dataclass
class Article:
    title: str
    date: str
    type: str
    image_url: str = ""
    article_url: str = ""
    summary: str = ""
    speaker_notes: str = ""
    file: str = ""

    @property
    def section_color(self) -> RGBColor:
        return SECTION_META.get(self.type, {}).get("color", COLOR_ACCENT)

    @property
    def section_title(self) -> str:
        return SECTION_META.get(self.type, {}).get("title", self.type)


# â”€â”€ Markdown parsing (pre-compiled regexes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_FRONT_MATTER_RE = re.compile(r"^---\s*\n(.*?)\n---\s*\n(.*)", re.DOTALL)
_SUMMARY_RE = re.compile(
    r"##\s*Summary\s*\n+(.*?)(?=\n<!--|\n##|\Z)", re.DOTALL | re.IGNORECASE
)
# Broader pattern: capture everything from the first ## heading to the speaker-notes comment
_BODY_CONTENT_RE = re.compile(
    r"\n##\s+.+?\n(.*?)(?=\n<!--|\Z)", re.DOTALL
)
_SPEAKER_NOTES_RE = re.compile(
    r"<!--\s*\n?\s*speaker_notes:\s*\n(.*?)\s*-->", re.DOTALL
)
_IMAGE_RE = re.compile(r"!\[.*?\]\((.*?)\)")


def parse_front_matter(text: str) -> tuple[dict, str]:
    """Split YAML front matter from markdown body."""
    m = _FRONT_MATTER_RE.match(text)
    if not m:
        return {}, text
    return yaml.safe_load(m.group(1)) or {}, m.group(2)


def extract_summary(body: str) -> str:
    """Extract the Summary section (or full structured body) from markdown."""
    m = _SUMMARY_RE.search(body)
    if m:
        return m.group(1).strip()
    # Try broader pattern: everything from the first ## heading onwards (including sub-headings)
    m2 = _BODY_CONTENT_RE.search(body)
    if m2:
        # Include the first ## heading line itself for context
        start = body.find("\n## ")
        if start != -1:
            block = body[start + 1:]  # from "## ..." onwards
            # Strip anything after speaker-notes comment
            block = re.sub(r"\n<!--.*", "", block, flags=re.DOTALL)
            return block.strip()
    # Fallback: text after the slide separator (---) that isn't front matter
    parts = re.split(r"\n---\s*\n", body, maxsplit=1)
    if len(parts) == 2:
        text = re.sub(r"<!--.*?-->", "", parts[1], flags=re.DOTALL)
        text = re.sub(r"^##.*$", "", text, flags=re.MULTILINE)
        return text.strip()
    return ""


def extract_speaker_notes(body: str) -> str:
    """Extract speaker notes from an HTML comment block."""
    m = _SPEAKER_NOTES_RE.search(body)
    return m.group(1).strip() if m else ""


def extract_image_url(body: str, front_matter: dict) -> str:
    """Get the hero image URL from front matter or markdown body."""
    url = front_matter.get("image_url", "")
    if url:
        return url
    m = _IMAGE_RE.search(body)
    return m.group(1) if m else ""


def normalize_type(raw: str) -> str:
    """Map any known type alias to its canonical key."""
    return _TYPE_ALIASES.get(raw.lower(), raw.lower())


# â”€â”€ Image helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def download_image(url: str, max_width: int = 1200) -> io.BytesIO | None:
    """Download an image, resize if needed, return as BytesIO (or None)."""
    if not url:
        return None
    try:
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) copilot-updates-pptx/1.0"
        }
        resp = requests.get(url, headers=headers, timeout=15)
        resp.raise_for_status()
        img = Image.open(io.BytesIO(resp.content))
        if img.width > max_width:
            ratio = max_width / img.width
            img = img.resize((max_width, int(img.height * ratio)), Image.LANCZOS)
        buf = io.BytesIO()
        fmt = "JPEG" if (img.format or "").upper() == "JPEG" else "PNG"
        img.save(buf, format=fmt, **({"quality": 85} if fmt == "JPEG" else {}))
        buf.seek(0)
        return buf
    except Exception as exc:
        print(f"  âš  Could not download image {url}: {exc}")
        return None


def _place_image(slide, image_stream: io.BytesIO, avail_top,
                 avail_w=Inches(10), avail_h=Inches(4)):
    """Scale an image to fit the available area and add it centered on the slide."""
    img = Image.open(image_stream)
    img_w, img_h = img.size
    image_stream.seek(0)

    emu_w = img_w * PX_TO_EMU
    emu_h = img_h * PX_TO_EMU
    scale = min(avail_w / Emu(emu_w), avail_h / Emu(emu_h), 1.0)

    pic_w = int(emu_w * scale)
    pic_h = int(emu_h * scale)
    left = int((SLIDE_WIDTH - pic_w) / 2)

    slide.shapes.add_picture(image_stream, left, int(avail_top), pic_w, pic_h)


def _resolve_image(image_stream: io.BytesIO | None, section_type: str) -> io.BytesIO | None:
    """Return the provided stream, falling back to a local placeholder image."""
    if image_stream:
        return image_stream
    fallback = FALLBACK_IMAGES.get(section_type)
    if fallback and fallback.exists():
        return io.BytesIO(fallback.read_bytes())
    return None


# â”€â”€ Slide builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _set_slide_bg(slide, color: RGBColor = COLOR_BG_DARK):
    """Set a solid background color on a slide."""
    fill = slide.background.fill
    fill.solid()
    fill.fore_color.rgb = color


def _add_text(slide, left, top, width, height, text, *,
              size=18, color=COLOR_TEXT_WHITE, bold=False,
              align=PP_ALIGN.LEFT, font="Segoe UI"):
    """Add a single-paragraph styled text box and return the shape."""
    box = slide.shapes.add_textbox(left, top, width, height)
    box.text_frame.word_wrap = True
    p = box.text_frame.paragraphs[0]
    p.text = text
    p.font.size = Pt(size)
    p.font.color.rgb = color
    p.font.bold = bold
    p.font.name = font
    p.alignment = align
    return box


def _blank_slide(prs: Presentation):
    """Add a blank slide with the dark background."""
    slide = prs.slides.add_slide(prs.slide_layouts[6])
    _set_slide_bg(slide)
    return slide


def create_title_slide(prs: Presentation, start_date: str, end_date: str):
    """Create the opening title slide."""
    slide = _blank_slide(prs)
    cx, cw = Inches(1), Inches(11.333)
    _add_text(slide, cx, Inches(2), cw, Inches(1.5),
              "GitHub Copilot Updates",
              size=44, color=COLOR_ACCENT, bold=True, align=PP_ALIGN.CENTER)
    _add_text(slide, cx, Inches(3.8), cw, Inches(1),
              f"{start_date}  â†’  {end_date}",
              size=24, color=COLOR_TEXT_LIGHT, align=PP_ALIGN.CENTER)
    _add_text(slide, cx, Inches(5.5), cw, Inches(0.6),
              "Source: github.blog/changelog",
              size=14, color=COLOR_TEXT_MUTED, align=PP_ALIGN.CENTER)


def create_section_slide(prs: Presentation, section_type: str, count: int):
    """Create a section divider slide."""
    slide = _blank_slide(prs)
    meta = SECTION_META.get(section_type, {})
    cx, cw = Inches(1), Inches(11.333)
    _add_text(slide, cx, Inches(2.5), cw, Inches(1.5),
              f"{meta.get('emoji', '')}  {meta.get('title', section_type)}",
              size=40, color=meta.get("color", COLOR_ACCENT),
              bold=True, align=PP_ALIGN.CENTER)
    _add_text(slide, cx, Inches(4.2), cw, Inches(0.8),
              f"{count} update{'s' if count != 1 else ''}",
              size=20, color=COLOR_TEXT_MUTED, align=PP_ALIGN.CENTER)


def create_article_title_slide(prs: Presentation, article: Article,
                               image_stream: io.BytesIO | None):
    """Create slide 1 for an article: title + hero image."""
    slide = _blank_slide(prs)
    color = article.section_color

    _add_text(slide, Inches(0.8), Inches(0.4), Inches(3), Inches(0.4),
              article.section_title.upper(), size=12, color=color, bold=True)
    _add_text(slide, Inches(0.8), Inches(0.8), Inches(3), Inches(0.4),
              article.date, size=12, color=COLOR_TEXT_MUTED)
    _add_text(slide, Inches(0.8), Inches(1.4), Inches(11.5), Inches(1.6),
              article.title, size=32, color=COLOR_TEXT_WHITE, bold=True)

    stream = _resolve_image(image_stream, article.type)
    if stream:
        try:
            _place_image(slide, stream, avail_top=Inches(3.2))
        except Exception as exc:
            print(f"  âš  Could not add image to slide: {exc}")
    else:
        _add_text(slide, Inches(1), Inches(4), Inches(11.333), Inches(1),
                  "(No image available)",
                  size=16, color=COLOR_TEXT_MUTED, align=PP_ALIGN.CENTER)


def _add_styled_runs(paragraph, text: str, *,
                     base_size: int = 16, base_color: RGBColor = COLOR_TEXT_LIGHT,
                     bold_color: RGBColor | None = None, font: str = "Segoe UI"):
    """Parse inline **bold** markers and add styled runs to a paragraph."""
    parts = re.split(r"(\*\*.*?\*\*)", text)
    for part in parts:
        if part.startswith("**") and part.endswith("**"):
            run = paragraph.add_run()
            run.text = part[2:-2]
            run.font.size = Pt(base_size)
            run.font.bold = True
            run.font.color.rgb = bold_color or COLOR_TEXT_WHITE
            run.font.name = font
        elif part:
            run = paragraph.add_run()
            run.text = part
            run.font.size = Pt(base_size)
            run.font.color.rgb = base_color
            run.font.name = font


def _compute_scale_factor(summary: str) -> float:
    """Return a font-scale factor (0.55 â€¦ 1.0) based on summary length.

    The heuristic counts "visual lines" â€“ i.e. how many wrapped lines the
    text would roughly occupy at the default font size on a slide that is
    ~11.5 inches wide with a ~16 pt Segoe UI font (~100 characters per line).
    """
    if not summary:
        return 1.0
    chars_per_line = 100
    raw_lines = summary.split("\n")
    visual_lines = 0
    for raw in raw_lines:
        line = raw.strip()
        if not line:
            visual_lines += 0.4          # blank line still takes some space
        else:
            visual_lines += max(1, len(line) / chars_per_line)
    # The available text area comfortably holds ~14 visual lines at scale 1.0
    max_comfortable = 14
    if visual_lines <= max_comfortable:
        return 1.0
    factor = max_comfortable / visual_lines
    return max(factor, 0.55)             # never shrink below 55 %


def create_article_summary_slide(prs: Presentation, article: Article):
    """Create slide 2 for an article: structured summary + speaker notes."""
    slide = _blank_slide(prs)

    # --- Compute a scale factor to shrink fonts when the body is long ---
    sf = _compute_scale_factor(article.summary)

    title_size = max(int(22 * sf), 14)
    heading_size = max(int(20 * sf), 13)
    sub_heading_size = max(int(13 * sf), 9)
    body_size = max(int(16 * sf), 10)
    bullet_size = body_size

    _add_text(slide, Inches(0.8), Inches(0.4), Inches(11.5), Inches(0.8),
              article.title, size=title_size, color=article.section_color, bold=True)

    box = slide.shapes.add_textbox(Inches(0.8), Inches(1.5), Inches(11.5), Inches(5.2))
    tf = box.text_frame
    tf.word_wrap = True

    first_para = True
    in_table = False

    # Pre-scan for table rows so we can render them as a real table
    lines = article.summary.split("\n")
    table_rows: list[list[str]] = []
    table_start_idx = -1
    non_table_lines: list[tuple[int, str]] = []

    for idx, raw_line in enumerate(lines):
        line = raw_line.strip()
        if not line:
            non_table_lines.append((idx, ""))
            continue
        # Skip separator rows
        if re.match(r"^\|[-\s|:]+\|$", line):
            continue
        if line.startswith("|") and line.endswith("|"):
            if table_start_idx == -1:
                table_start_idx = idx
            table_rows.append([c.strip() for c in line.strip("|").split("|")])
        else:
            non_table_lines.append((idx, line))

    # Render real table if we found table rows
    if table_rows and len(table_rows) >= 2:
        n_cols = len(table_rows[0])
        n_rows = len(table_rows)
        tbl_width = Inches(9)
        tbl_left = Inches(0.8)
        # We'll place the table after the heading; calculate later
        _table_placeholder = (tbl_left, n_rows, n_cols, tbl_width, table_rows)
    else:
        _table_placeholder = None

    for idx, raw_line in non_table_lines:
        line = raw_line.strip() if raw_line else ""
        if not line:
            continue

        # --- ## Main heading
        if line.startswith("## "):
            heading_text = line.lstrip("# ").strip()
            p = tf.paragraphs[0] if first_para else tf.add_paragraph()
            first_para = False
            run = p.add_run()
            run.text = heading_text
            run.font.size = Pt(heading_size)
            run.font.bold = True
            run.font.color.rgb = COLOR_TEXT_WHITE
            run.font.name = "Segoe UI"
            p.space_before = Pt(max(int(8 * sf), 4))
            p.space_after = Pt(max(int(6 * sf), 3))
            continue

        # --- ### Sub-heading
        if line.startswith("### "):
            heading_text = line.lstrip("# ").strip()
            p = tf.paragraphs[0] if first_para else tf.add_paragraph()
            first_para = False
            p.space_before = Pt(max(int(14 * sf), 6))
            p.space_after = Pt(max(int(4 * sf), 2))
            run = p.add_run()
            run.text = heading_text.upper()
            run.font.size = Pt(sub_heading_size)
            run.font.bold = True
            run.font.color.rgb = article.section_color
            run.font.name = "Segoe UI"
            continue

        # --- Bullet point (- text or numbered 1. text)
        if re.match(r"^[-â€¢]\s+", line) or re.match(r"^\d+\.\s+", line):
            text = re.sub(r"^[-â€¢]\s+", "", line)
            text = re.sub(r"^\d+\.\s+", "", text)
            p = tf.paragraphs[0] if first_para else tf.add_paragraph()
            first_para = False
            p.level = 0
            p.space_after = Pt(max(int(4 * sf), 2))
            # Add bullet character
            bullet_run = p.add_run()
            bullet_run.text = "â€¢  "
            bullet_run.font.size = Pt(bullet_size)
            bullet_run.font.color.rgb = article.section_color
            bullet_run.font.name = "Segoe UI"
            _add_styled_runs(p, text, base_size=body_size, base_color=COLOR_TEXT_LIGHT)
            continue

        # --- Regular paragraph text
        p = tf.paragraphs[0] if first_para else tf.add_paragraph()
        first_para = False
        _add_styled_runs(p, line, base_size=body_size, base_color=COLOR_TEXT_LIGHT)
        p.space_after = Pt(max(int(8 * sf), 4))

    # --- Insert real table if present
    if _table_placeholder:
        tbl_left, n_rows, n_cols, tbl_width, rows_data = _table_placeholder
        row_h = Inches(0.35)
        tbl_height = row_h * n_rows
        # Simple heuristic: count rendered paragraphs to estimate Y position
        n_paras = len([p for p in tf.paragraphs if p.text.strip()])
        tbl_top = int(Inches(1.5) + Pt(24) * min(n_paras, 4))
        table_shape = slide.shapes.add_table(n_rows, n_cols, tbl_left, tbl_top, tbl_width, tbl_height)
        tbl = table_shape.table

        for r, row_data in enumerate(rows_data):
            for c, cell_text in enumerate(row_data):
                cell = tbl.cell(r, c)
                cell.text = ""
                p = cell.text_frame.paragraphs[0]
                # Strip bold markers for cell text
                clean = re.sub(r"\*\*(.*?)\*\*", r"\1", cell_text)
                p.text = clean
                p.font.size = Pt(14)
                p.font.name = "Segoe UI"
                p.font.color.rgb = COLOR_TEXT_WHITE if r == 0 else COLOR_TEXT_LIGHT
                p.font.bold = r == 0
                # Cell background
                tcPr = cell._tc.get_or_add_tcPr()
                solidFill = tcPr.makeelement(qn("a:solidFill"), {})
                srgbClr = solidFill.makeelement(qn("a:srgbClr"), {"val": "161B22" if r == 0 else "0D1117"})
                solidFill.append(srgbClr)
                tcPr.append(solidFill)

        # Style table borders
        tbl_xml = tbl._tbl
        tblPr = tbl_xml.tblPr
        if tblPr is None:
            tblPr = tbl_xml.makeelement(qn("a:tblPr"), {})
            tbl_xml.insert(0, tblPr)
        # Remove default borders by setting bandRow off
        tblPr.set("bandRow", "0")
        tblPr.set("bandCol", "0")
        tblPr.set("firstRow", "1")

    # --- Clickable URL link
    if article.article_url:
        link_box = slide.shapes.add_textbox(
            Inches(0.8), Inches(7.0), Inches(11.5), Inches(0.4)
        )
        link_box.text_frame.word_wrap = True
        p = link_box.text_frame.paragraphs[0]
        run = p.add_run()
        run.text = f"\U0001f517 {article.article_url}"
        run.font.size = Pt(10)
        run.font.color.rgb = COLOR_TEXT_MUTED
        run.font.name = "Segoe UI"
        # Make it a real hyperlink
        r_elem = run._r
        hlinkClick = r_elem.makeelement(qn("a:hlinkClick"), {})
        hlinkClick.set(qn("r:id"), slide.part.relate_to(
            article.article_url, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
            is_external=True
        ))
        rPr = r_elem.find(qn("a:rPr"))
        if rPr is None:
            rPr = r_elem.makeelement(qn("a:rPr"), {})
            r_elem.insert(0, rPr)
        rPr.append(hlinkClick)

    if article.speaker_notes:
        slide.notes_slide.notes_text_frame.text = article.speaker_notes


# â”€â”€ File discovery â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def discover_articles(output_dir: Path, *,
                      from_date: str = "", to_date: str = "") -> dict[str, list[Article]]:
    """Scan output directories and return articles grouped by canonical type.

    If *from_date* / *to_date* are given (YYYY-MM-DD strings) only articles
    whose front-matter date falls within [from_date, to_date] are kept.
    """
    articles: dict[str, list[Article]] = {t: [] for t in SECTION_ORDER}

    for section_type in SECTION_ORDER:
        dir_path = output_dir / SECTION_META[section_type]["dir"]
        if not dir_path.is_dir():
            continue
        for md in sorted(dir_path.glob("*.md")):
            text = md.read_text(encoding="utf-8")
            fm, body = parse_front_matter(text)
            article_date = str(fm.get("date", ""))
            # --- date-range filter ---
            if from_date and article_date and article_date < from_date:
                continue
            if to_date and article_date and article_date > to_date:
                continue
            resolved = normalize_type(fm.get("type", section_type))
            articles.setdefault(resolved, []).append(Article(
                title=fm.get("title", md.stem),
                date=article_date,
                type=resolved,
                image_url=extract_image_url(body, fm),
                article_url=fm.get("article_url", ""),
                summary=extract_summary(body),
                speaker_notes=extract_speaker_notes(body),
                file=str(md),
            ))

    return articles


# â”€â”€ Presentation orchestrator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def build_presentation(articles_by_type: dict[str, list[Article]],
                       start_date: str, end_date: str,
                       output_path: str):
    """Build the complete PowerPoint presentation."""
    prs = Presentation()
    prs.slide_width = SLIDE_WIDTH
    prs.slide_height = SLIDE_HEIGHT

    create_title_slide(prs, start_date, end_date)

    total = sum(len(v) for v in articles_by_type.values())
    processed = 0

    for section_type in SECTION_ORDER:
        articles = articles_by_type.get(section_type, [])
        if not articles:
            continue

        create_section_slide(prs, section_type, len(articles))
        articles.sort(key=lambda a: a.date)

        for article in articles:
            processed += 1
            print(f"  [{processed}/{total}] {article.title}")
            img = download_image(article.image_url)
            create_article_title_slide(prs, article, img)
            create_article_summary_slide(prs, article)

    prs.save(output_path)
    print(f"\nâœ… Presentation saved to: {output_path}")
    print(f"   Total slides: {len(prs.slides)}")


# â”€â”€ Date-range detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def detect_date_range(output_dir: Path) -> tuple[str, str]:
    """Detect date range from index.md or article front matter."""
    index = output_dir / "index.md"
    if index.exists():
        m = re.search(
            r"(\d{4}-\d{2}-\d{2})\s*[-â€“â€”]\s*(\d{4}-\d{2}-\d{2})",
            index.read_text(encoding="utf-8"),
        )
        if m:
            return m.group(1), m.group(2)

    dates: list[str] = []
    for md in output_dir.rglob("*.md"):
        if md.name == "index.md":
            continue
        fm, _ = parse_front_matter(md.read_text(encoding="utf-8"))
        d = str(fm.get("date", ""))
        if d:
            dates.append(d)

    if dates:
        dates.sort()
        return dates[0], dates[-1]
    return "unknown", "unknown"


# â”€â”€ CLI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    parser = argparse.ArgumentParser(
        description="Convert Copilot changelog markdown files to PowerPoint",
    )
    parser.add_argument("-d", "--output-dir", default="output",
                        help="Directory containing markdown files (default: output/)")
    parser.add_argument("-l", "--locale", default="en",
                        help="Locale subfolder to read from (default: en)")
    parser.add_argument("-o", "--output", default="",
                        help="Output .pptx filename (auto-generated if omitted)")
    parser.add_argument("--from-date", default="",
                        help="Start date for title slide (auto-detected)")
    parser.add_argument("--to-date", default="",
                        help="End date for title slide (auto-detected)")
    args = parser.parse_args()

    output_dir = Path(args.output_dir) / args.locale
    if not output_dir.is_dir():
        print(f"âŒ Output directory not found: {output_dir}")
        print("   Run the Copilot agent first to generate markdown files.")
        sys.exit(1)

    print("ğŸ“‚ Scanning for articles...")
    articles_by_type = discover_articles(
        output_dir, from_date=args.from_date, to_date=args.to_date
    )

    total = sum(len(v) for v in articles_by_type.values())
    if total == 0:
        print("âŒ No articles found. Ensure .md files exist in:")
        for meta in SECTION_META.values():
            print(f"   {output_dir}/{meta['dir']}/")
        sys.exit(1)

    for stype, arts in articles_by_type.items():
        if arts:
            print(f"   {SECTION_META[stype]['title']}: {len(arts)} articles")

    # Resolve date range
    start = args.from_date
    end = args.to_date
    if not start or not end:
        ds, de = detect_date_range(output_dir)
        start = start or ds
        end = end or de

    output_path = args.output or f"copilot-updates-{start}-to-{end}.pptx"

    print(f"\nğŸ”¨ Building presentation ({start} â†’ {end})...")
    build_presentation(articles_by_type, start, end, output_path)


if __name__ == "__main__":
    main()
