#!/usr/bin/env python3
"""
Convert markdown article files (generated by the Copilot agent) into a PowerPoint presentation.

Usage:
    python create_pptx.py [--output OUTPUT.pptx] [--output-dir output/]

The script reads all .md files from output/{new-releases,improvements,deprecations}/,
parses the YAML front matter and body content, and creates a .pptx with:
  - A title slide for the presentation
  - Section divider slides for each category
  - For each article: Slide 1 = title + image, Slide 2 = summary + speaker notes
"""

from __future__ import annotations

import argparse
import io
import re
import sys
from dataclasses import dataclass
from pathlib import Path

import requests
import yaml
from PIL import Image
from pptx import Presentation
from pptx.util import Inches, Pt, Emu
from pptx.enum.text import PP_ALIGN
from pptx.dml.color import RGBColor


# â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Slide dimensions (widescreen 16:9)
SLIDE_WIDTH = Inches(13.333)
SLIDE_HEIGHT = Inches(7.5)

# Color palette (GitHub dark theme)
COLOR_BG_DARK = RGBColor(0x0D, 0x11, 0x17)
COLOR_ACCENT = RGBColor(0x58, 0xA6, 0xFF)
COLOR_TEXT_WHITE = RGBColor(0xFF, 0xFF, 0xFF)
COLOR_TEXT_LIGHT = RGBColor(0xC9, 0xD1, 0xD9)
COLOR_TEXT_MUTED = RGBColor(0x8B, 0x94, 0x9E)

# Per-section theming (single source of truth)
SECTION_META: dict[str, dict] = {
    "new-release": {
        "color": RGBColor(0x3F, 0xB9, 0x50),
        "emoji": "ğŸš€",
        "title": "New Releases",
        "dir": "new-releases",
    },
    "improvement": {
        "color": RGBColor(0x58, 0xA6, 0xFF),
        "emoji": "âœ¨",
        "title": "Improvements",
        "dir": "improvements",
    },
    "deprecation": {
        "color": RGBColor(0xF8, 0x54, 0x49),
        "emoji": "âš ï¸",
        "title": "Deprecations",
        "dir": "deprecations",
    },
}

SECTION_ORDER = ("new-release", "improvement", "deprecation")

# Front-matter type aliases â†’ canonical key
_TYPE_ALIASES: dict[str, str] = {
    "new-releases": "new-release",
    "new-release": "new-release",
    "release": "new-release",
    "improvements": "improvement",
    "improvement": "improvement",
    "deprecations": "deprecation",
    "deprecation": "deprecation",
    "retired": "deprecation",
}

SCRIPT_DIR = Path(__file__).resolve().parent
FALLBACK_IMAGES: dict[str, Path] = {
    key: SCRIPT_DIR / "imgs" / f"featured-v3-{meta['dir']}.png"
    for key, meta in SECTION_META.items()
}

PX_TO_EMU = 914400 // 96  # EMUs per pixel at 96 DPI


# â”€â”€ Data model â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@dataclass
class Article:
    title: str
    date: str
    type: str
    image_url: str = ""
    article_url: str = ""
    summary: str = ""
    speaker_notes: str = ""
    file: str = ""

    @property
    def section_color(self) -> RGBColor:
        return SECTION_META.get(self.type, {}).get("color", COLOR_ACCENT)

    @property
    def section_title(self) -> str:
        return SECTION_META.get(self.type, {}).get("title", self.type)


# â”€â”€ Markdown parsing (pre-compiled regexes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_FRONT_MATTER_RE = re.compile(r"^---\s*\n(.*?)\n---\s*\n(.*)", re.DOTALL)
_SUMMARY_RE = re.compile(
    r"##\s*Summary\s*\n+(.*?)(?=\n<!--|\n##|\Z)", re.DOTALL | re.IGNORECASE
)
_SPEAKER_NOTES_RE = re.compile(
    r"<!--\s*\n?\s*speaker_notes:\s*\n(.*?)\s*-->", re.DOTALL
)
_IMAGE_RE = re.compile(r"!\[.*?\]\((.*?)\)")


def parse_front_matter(text: str) -> tuple[dict, str]:
    """Split YAML front matter from markdown body."""
    m = _FRONT_MATTER_RE.match(text)
    if not m:
        return {}, text
    return yaml.safe_load(m.group(1)) or {}, m.group(2)


def extract_summary(body: str) -> str:
    """Extract the Summary section from the markdown body."""
    m = _SUMMARY_RE.search(body)
    if m:
        return m.group(1).strip()
    # Fallback: text after the slide separator (---) that isn't front matter
    parts = re.split(r"\n---\s*\n", body, maxsplit=1)
    if len(parts) == 2:
        text = re.sub(r"<!--.*?-->", "", parts[1], flags=re.DOTALL)
        text = re.sub(r"^##.*$", "", text, flags=re.MULTILINE)
        return text.strip()
    return ""


def extract_speaker_notes(body: str) -> str:
    """Extract speaker notes from an HTML comment block."""
    m = _SPEAKER_NOTES_RE.search(body)
    return m.group(1).strip() if m else ""


def extract_image_url(body: str, front_matter: dict) -> str:
    """Get the hero image URL from front matter or markdown body."""
    url = front_matter.get("image_url", "")
    if url:
        return url
    m = _IMAGE_RE.search(body)
    return m.group(1) if m else ""


def normalize_type(raw: str) -> str:
    """Map any known type alias to its canonical key."""
    return _TYPE_ALIASES.get(raw.lower(), raw.lower())


# â”€â”€ Image helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def download_image(url: str, max_width: int = 1200) -> io.BytesIO | None:
    """Download an image, resize if needed, return as BytesIO (or None)."""
    if not url:
        return None
    try:
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) copilot-updates-pptx/1.0"
        }
        resp = requests.get(url, headers=headers, timeout=15)
        resp.raise_for_status()
        img = Image.open(io.BytesIO(resp.content))
        if img.width > max_width:
            ratio = max_width / img.width
            img = img.resize((max_width, int(img.height * ratio)), Image.LANCZOS)
        buf = io.BytesIO()
        fmt = "JPEG" if (img.format or "").upper() == "JPEG" else "PNG"
        img.save(buf, format=fmt, **({"quality": 85} if fmt == "JPEG" else {}))
        buf.seek(0)
        return buf
    except Exception as exc:
        print(f"  âš  Could not download image {url}: {exc}")
        return None


def _place_image(slide, image_stream: io.BytesIO, avail_top,
                 avail_w=Inches(10), avail_h=Inches(4)):
    """Scale an image to fit the available area and add it centered on the slide."""
    img = Image.open(image_stream)
    img_w, img_h = img.size
    image_stream.seek(0)

    emu_w = img_w * PX_TO_EMU
    emu_h = img_h * PX_TO_EMU
    scale = min(avail_w / Emu(emu_w), avail_h / Emu(emu_h), 1.0)

    pic_w = int(emu_w * scale)
    pic_h = int(emu_h * scale)
    left = int((SLIDE_WIDTH - pic_w) / 2)

    slide.shapes.add_picture(image_stream, left, int(avail_top), pic_w, pic_h)


def _resolve_image(image_stream: io.BytesIO | None, section_type: str) -> io.BytesIO | None:
    """Return the provided stream, falling back to a local placeholder image."""
    if image_stream:
        return image_stream
    fallback = FALLBACK_IMAGES.get(section_type)
    if fallback and fallback.exists():
        return io.BytesIO(fallback.read_bytes())
    return None


# â”€â”€ Slide builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _set_slide_bg(slide, color: RGBColor = COLOR_BG_DARK):
    """Set a solid background color on a slide."""
    fill = slide.background.fill
    fill.solid()
    fill.fore_color.rgb = color


def _add_text(slide, left, top, width, height, text, *,
              size=18, color=COLOR_TEXT_WHITE, bold=False,
              align=PP_ALIGN.LEFT, font="Segoe UI"):
    """Add a single-paragraph styled text box and return the shape."""
    box = slide.shapes.add_textbox(left, top, width, height)
    box.text_frame.word_wrap = True
    p = box.text_frame.paragraphs[0]
    p.text = text
    p.font.size = Pt(size)
    p.font.color.rgb = color
    p.font.bold = bold
    p.font.name = font
    p.alignment = align
    return box


def _blank_slide(prs: Presentation):
    """Add a blank slide with the dark background."""
    slide = prs.slides.add_slide(prs.slide_layouts[6])
    _set_slide_bg(slide)
    return slide


def create_title_slide(prs: Presentation, start_date: str, end_date: str):
    """Create the opening title slide."""
    slide = _blank_slide(prs)
    cx, cw = Inches(1), Inches(11.333)
    _add_text(slide, cx, Inches(2), cw, Inches(1.5),
              "GitHub Copilot Updates",
              size=44, color=COLOR_ACCENT, bold=True, align=PP_ALIGN.CENTER)
    _add_text(slide, cx, Inches(3.8), cw, Inches(1),
              f"{start_date}  â†’  {end_date}",
              size=24, color=COLOR_TEXT_LIGHT, align=PP_ALIGN.CENTER)
    _add_text(slide, cx, Inches(5.5), cw, Inches(0.6),
              "Source: github.blog/changelog",
              size=14, color=COLOR_TEXT_MUTED, align=PP_ALIGN.CENTER)


def create_section_slide(prs: Presentation, section_type: str, count: int):
    """Create a section divider slide."""
    slide = _blank_slide(prs)
    meta = SECTION_META.get(section_type, {})
    cx, cw = Inches(1), Inches(11.333)
    _add_text(slide, cx, Inches(2.5), cw, Inches(1.5),
              f"{meta.get('emoji', '')}  {meta.get('title', section_type)}",
              size=40, color=meta.get("color", COLOR_ACCENT),
              bold=True, align=PP_ALIGN.CENTER)
    _add_text(slide, cx, Inches(4.2), cw, Inches(0.8),
              f"{count} update{'s' if count != 1 else ''}",
              size=20, color=COLOR_TEXT_MUTED, align=PP_ALIGN.CENTER)


def create_article_title_slide(prs: Presentation, article: Article,
                               image_stream: io.BytesIO | None):
    """Create slide 1 for an article: title + hero image."""
    slide = _blank_slide(prs)
    color = article.section_color

    _add_text(slide, Inches(0.8), Inches(0.4), Inches(3), Inches(0.4),
              article.section_title.upper(), size=12, color=color, bold=True)
    _add_text(slide, Inches(0.8), Inches(0.8), Inches(3), Inches(0.4),
              article.date, size=12, color=COLOR_TEXT_MUTED)
    _add_text(slide, Inches(0.8), Inches(1.4), Inches(11.5), Inches(1.6),
              article.title, size=32, color=COLOR_TEXT_WHITE, bold=True)

    stream = _resolve_image(image_stream, article.type)
    if stream:
        try:
            _place_image(slide, stream, avail_top=Inches(3.2))
        except Exception as exc:
            print(f"  âš  Could not add image to slide: {exc}")
    else:
        _add_text(slide, Inches(1), Inches(4), Inches(11.333), Inches(1),
                  "(No image available)",
                  size=16, color=COLOR_TEXT_MUTED, align=PP_ALIGN.CENTER)


def create_article_summary_slide(prs: Presentation, article: Article):
    """Create slide 2 for an article: summary + speaker notes."""
    slide = _blank_slide(prs)

    _add_text(slide, Inches(0.8), Inches(0.4), Inches(11.5), Inches(0.8),
              article.title, size=22, color=article.section_color, bold=True)

    # Summary paragraphs
    box = slide.shapes.add_textbox(Inches(0.8), Inches(1.5), Inches(11.5), Inches(4.5))
    tf = box.text_frame
    tf.word_wrap = True
    for i, line in enumerate(ln.strip() for ln in article.summary.split("\n") if ln.strip()):
        p = tf.paragraphs[0] if i == 0 else tf.add_paragraph()
        p.text = line
        p.font.size = Pt(18)
        p.font.color.rgb = COLOR_TEXT_LIGHT
        p.font.name = "Segoe UI"
        p.space_after = Pt(12)

    if article.article_url:
        _add_text(slide, Inches(0.8), Inches(6.5), Inches(11.5), Inches(0.5),
                  f"ğŸ”— {article.article_url}", size=11, color=COLOR_TEXT_MUTED)

    if article.speaker_notes:
        slide.notes_slide.notes_text_frame.text = article.speaker_notes


# â”€â”€ File discovery â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def discover_articles(output_dir: Path) -> dict[str, list[Article]]:
    """Scan output directories and return articles grouped by canonical type."""
    articles: dict[str, list[Article]] = {t: [] for t in SECTION_ORDER}

    for section_type in SECTION_ORDER:
        dir_path = output_dir / SECTION_META[section_type]["dir"]
        if not dir_path.is_dir():
            continue
        for md in sorted(dir_path.glob("*.md")):
            text = md.read_text(encoding="utf-8")
            fm, body = parse_front_matter(text)
            resolved = normalize_type(fm.get("type", section_type))
            articles.setdefault(resolved, []).append(Article(
                title=fm.get("title", md.stem),
                date=str(fm.get("date", "")),
                type=resolved,
                image_url=extract_image_url(body, fm),
                article_url=fm.get("article_url", ""),
                summary=extract_summary(body),
                speaker_notes=extract_speaker_notes(body),
                file=str(md),
            ))

    return articles


# â”€â”€ Presentation orchestrator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def build_presentation(articles_by_type: dict[str, list[Article]],
                       start_date: str, end_date: str,
                       output_path: str):
    """Build the complete PowerPoint presentation."""
    prs = Presentation()
    prs.slide_width = SLIDE_WIDTH
    prs.slide_height = SLIDE_HEIGHT

    create_title_slide(prs, start_date, end_date)

    total = sum(len(v) for v in articles_by_type.values())
    processed = 0

    for section_type in SECTION_ORDER:
        articles = articles_by_type.get(section_type, [])
        if not articles:
            continue

        create_section_slide(prs, section_type, len(articles))
        articles.sort(key=lambda a: a.date)

        for article in articles:
            processed += 1
            print(f"  [{processed}/{total}] {article.title}")
            img = download_image(article.image_url)
            create_article_title_slide(prs, article, img)
            create_article_summary_slide(prs, article)

    prs.save(output_path)
    print(f"\nâœ… Presentation saved to: {output_path}")
    print(f"   Total slides: {len(prs.slides)}")


# â”€â”€ Date-range detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def detect_date_range(output_dir: Path) -> tuple[str, str]:
    """Detect date range from index.md or article front matter."""
    index = output_dir / "index.md"
    if index.exists():
        m = re.search(
            r"(\d{4}-\d{2}-\d{2})\s*[-â€“â€”]\s*(\d{4}-\d{2}-\d{2})",
            index.read_text(encoding="utf-8"),
        )
        if m:
            return m.group(1), m.group(2)

    dates: list[str] = []
    for md in output_dir.rglob("*.md"):
        if md.name == "index.md":
            continue
        fm, _ = parse_front_matter(md.read_text(encoding="utf-8"))
        d = str(fm.get("date", ""))
        if d:
            dates.append(d)

    if dates:
        dates.sort()
        return dates[0], dates[-1]
    return "unknown", "unknown"


# â”€â”€ CLI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    parser = argparse.ArgumentParser(
        description="Convert Copilot changelog markdown files to PowerPoint",
    )
    parser.add_argument("-d", "--output-dir", default="output",
                        help="Directory containing markdown files (default: output/)")
    parser.add_argument("-o", "--output", default="",
                        help="Output .pptx filename (auto-generated if omitted)")
    parser.add_argument("--from-date", default="",
                        help="Start date for title slide (auto-detected)")
    parser.add_argument("--to-date", default="",
                        help="End date for title slide (auto-detected)")
    args = parser.parse_args()

    output_dir = Path(args.output_dir)
    if not output_dir.is_dir():
        print(f"âŒ Output directory not found: {output_dir}")
        print("   Run the Copilot agent first to generate markdown files.")
        sys.exit(1)

    print("ğŸ“‚ Scanning for articles...")
    articles_by_type = discover_articles(output_dir)

    total = sum(len(v) for v in articles_by_type.values())
    if total == 0:
        print("âŒ No articles found. Ensure .md files exist in:")
        for meta in SECTION_META.values():
            print(f"   {output_dir}/{meta['dir']}/")
        sys.exit(1)

    for stype, arts in articles_by_type.items():
        if arts:
            print(f"   {SECTION_META[stype]['title']}: {len(arts)} articles")

    # Resolve date range
    start = args.from_date
    end = args.to_date
    if not start or not end:
        ds, de = detect_date_range(output_dir)
        start = start or ds
        end = end or de

    output_path = args.output or f"copilot-updates-{start}-to-{end}.pptx"

    print(f"\nğŸ”¨ Building presentation ({start} â†’ {end})...")
    build_presentation(articles_by_type, start, end, output_path)


if __name__ == "__main__":
    main()
