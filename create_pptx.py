#!/usr/bin/env python3
"""
Convert markdown article files (generated by the Copilot agent) into a PowerPoint presentation.

Usage:
    python create_pptx.py [--output OUTPUT.pptx] [--output-dir output/]

The script reads all .md files from output/{new-releases,improvements,deprecations}/,
parses the YAML front matter and body content, and creates a .pptx with:
  - A title slide for the presentation
  - Section divider slides for each category
  - For each article: Slide 1 = title + image, Slide 2 = summary + speaker notes
"""

import argparse
import io
import os
import re
import sys
import tempfile
from pathlib import Path

import requests
import yaml
from PIL import Image
from pptx import Presentation
from pptx.util import Inches, Pt, Emu
from pptx.enum.text import PP_ALIGN, MSO_ANCHOR
from pptx.dml.color import RGBColor


# ---------------------------------------------------------------------------
# Markdown parsing helpers
# ---------------------------------------------------------------------------

def parse_front_matter(text: str) -> tuple[dict, str]:
    """Split YAML front matter from markdown body."""
    match = re.match(r"^---\s*\n(.*?)\n---\s*\n(.*)", text, re.DOTALL)
    if not match:
        return {}, text
    fm = yaml.safe_load(match.group(1)) or {}
    body = match.group(2)
    return fm, body


def extract_summary(body: str) -> str:
    """Extract the summary section from the markdown body."""
    # Look for ## Summary heading and grab everything until the next heading or comment
    match = re.search(
        r"##\s*Summary\s*\n+(.*?)(?=\n<!--|\n##|\Z)", body, re.DOTALL | re.IGNORECASE
    )
    if match:
        return match.group(1).strip()
    # Fallback: everything after the slide separator (---) that isn't the front matter
    parts = re.split(r"\n---\s*\n", body, maxsplit=1)
    if len(parts) == 2:
        text = parts[1]
        # Remove HTML comments
        text = re.sub(r"<!--.*?-->", "", text, flags=re.DOTALL)
        # Remove headings
        text = re.sub(r"^##.*$", "", text, flags=re.MULTILINE)
        return text.strip()
    return ""


def extract_speaker_notes(body: str) -> str:
    """Extract speaker notes from an HTML comment block."""
    match = re.search(
        r"<!--\s*\n?\s*speaker_notes:\s*\n(.*?)\s*-->", body, re.DOTALL
    )
    if match:
        return match.group(1).strip()
    return ""


def extract_image_url(body: str, front_matter: dict) -> str:
    """Get the hero image URL from front matter or markdown body."""
    url = front_matter.get("image_url", "")
    if url:
        return url
    match = re.search(r"!\[.*?\]\((.*?)\)", body)
    if match:
        return match.group(1)
    return ""


# ---------------------------------------------------------------------------
# Image downloading
# ---------------------------------------------------------------------------

def download_image(url: str, max_width: int = 1200) -> io.BytesIO | None:
    """Download an image and return it as a BytesIO stream."""
    if not url:
        return None
    try:
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) copilot-updates-pptx/1.0"
        }
        resp = requests.get(url, headers=headers, timeout=15, stream=True)
        resp.raise_for_status()
        img_data = io.BytesIO(resp.content)
        # Validate it's actually an image
        img = Image.open(img_data)
        # Resize if too large (keeps aspect ratio)
        if img.width > max_width:
            ratio = max_width / img.width
            new_size = (max_width, int(img.height * ratio))
            img = img.resize(new_size, Image.LANCZOS)
        buf = io.BytesIO()
        img_format = img.format or "PNG"
        if img_format.upper() == "JPEG":
            img.save(buf, format="JPEG", quality=85)
        else:
            img.save(buf, format="PNG")
        buf.seek(0)
        return buf
    except Exception as e:
        print(f"  ‚ö† Could not download image {url}: {e}")
        return None


# ---------------------------------------------------------------------------
# Presentation building
# ---------------------------------------------------------------------------

# Slide dimensions (widescreen 16:9)
SLIDE_WIDTH = Inches(13.333)
SLIDE_HEIGHT = Inches(7.5)

# Colors
COLOR_BG_DARK = RGBColor(0x0D, 0x11, 0x17)       # GitHub dark bg
COLOR_ACCENT = RGBColor(0x58, 0xA6, 0xFF)          # GitHub blue
COLOR_TEXT_WHITE = RGBColor(0xFF, 0xFF, 0xFF)
COLOR_TEXT_LIGHT = RGBColor(0xC9, 0xD1, 0xD9)
COLOR_TEXT_MUTED = RGBColor(0x8B, 0x94, 0x9E)
COLOR_NEW_RELEASE = RGBColor(0x3F, 0xB9, 0x50)     # Green
COLOR_IMPROVEMENT = RGBColor(0x58, 0xA6, 0xFF)     # Blue
COLOR_DEPRECATION = RGBColor(0xF8, 0x54, 0x49)     # Red


SECTION_COLORS = {
    "new-release": COLOR_NEW_RELEASE,
    "improvement": COLOR_IMPROVEMENT,
    "deprecation": COLOR_DEPRECATION,
}

SECTION_EMOJI = {
    "new-release": "üöÄ",
    "improvement": "‚ú®",
    "deprecation": "‚ö†Ô∏è",
}

SECTION_TITLES = {
    "new-release": "New Releases",
    "improvement": "Improvements",
    "deprecation": "Deprecations",
}

# Fallback images (relative to the script directory)
SCRIPT_DIR = Path(__file__).resolve().parent
FALLBACK_IMAGES = {
    "new-release": SCRIPT_DIR / "imgs" / "featured-v3-new-releases.png",
    "improvement": SCRIPT_DIR / "imgs" / "featured-v3-improvements.png",
    "deprecation": SCRIPT_DIR / "imgs" / "featured-v3-deprecations.png",
}


def set_slide_bg(slide, color: RGBColor):
    """Set a solid background color on a slide."""
    background = slide.background
    fill = background.fill
    fill.solid()
    fill.fore_color.rgb = color


def add_textbox(slide, left, top, width, height, text, font_size=18,
                color=COLOR_TEXT_WHITE, bold=False, alignment=PP_ALIGN.LEFT,
                font_name="Segoe UI"):
    """Helper to add a styled text box."""
    txBox = slide.shapes.add_textbox(left, top, width, height)
    tf = txBox.text_frame
    tf.word_wrap = True
    p = tf.paragraphs[0]
    p.text = text
    p.font.size = Pt(font_size)
    p.font.color.rgb = color
    p.font.bold = bold
    p.font.name = font_name
    p.alignment = alignment
    return txBox


def create_title_slide(prs: Presentation, start_date: str, end_date: str):
    """Create the opening title slide."""
    slide = prs.slides.add_slide(prs.slide_layouts[6])  # Blank layout
    set_slide_bg(slide, COLOR_BG_DARK)

    # Main title
    add_textbox(
        slide,
        left=Inches(1), top=Inches(2),
        width=Inches(11.333), height=Inches(1.5),
        text="GitHub Copilot Updates",
        font_size=44, color=COLOR_ACCENT, bold=True,
        alignment=PP_ALIGN.CENTER,
    )

    # Subtitle with date range
    add_textbox(
        slide,
        left=Inches(1), top=Inches(3.8),
        width=Inches(11.333), height=Inches(1),
        text=f"{start_date}  ‚Üí  {end_date}",
        font_size=24, color=COLOR_TEXT_LIGHT,
        alignment=PP_ALIGN.CENTER,
    )

    # Footer
    add_textbox(
        slide,
        left=Inches(1), top=Inches(5.5),
        width=Inches(11.333), height=Inches(0.6),
        text="Source: github.blog/changelog",
        font_size=14, color=COLOR_TEXT_MUTED,
        alignment=PP_ALIGN.CENTER,
    )


def create_section_slide(prs: Presentation, section_type: str, count: int):
    """Create a section divider slide."""
    slide = prs.slides.add_slide(prs.slide_layouts[6])
    set_slide_bg(slide, COLOR_BG_DARK)

    emoji = SECTION_EMOJI.get(section_type, "")
    title = SECTION_TITLES.get(section_type, section_type)
    color = SECTION_COLORS.get(section_type, COLOR_ACCENT)

    add_textbox(
        slide,
        left=Inches(1), top=Inches(2.5),
        width=Inches(11.333), height=Inches(1.5),
        text=f"{emoji}  {title}",
        font_size=40, color=color, bold=True,
        alignment=PP_ALIGN.CENTER,
    )

    add_textbox(
        slide,
        left=Inches(1), top=Inches(4.2),
        width=Inches(11.333), height=Inches(0.8),
        text=f"{count} update{'s' if count != 1 else ''}",
        font_size=20, color=COLOR_TEXT_MUTED,
        alignment=PP_ALIGN.CENTER,
    )


def create_article_title_slide(prs: Presentation, title: str, date: str,
                                section_type: str, image_stream: io.BytesIO | None):
    """Create slide 1 for an article: title + hero image."""
    slide = prs.slides.add_slide(prs.slide_layouts[6])
    set_slide_bg(slide, COLOR_BG_DARK)

    color = SECTION_COLORS.get(section_type, COLOR_ACCENT)

    # Type badge
    add_textbox(
        slide,
        left=Inches(0.8), top=Inches(0.4),
        width=Inches(3), height=Inches(0.4),
        text=SECTION_TITLES.get(section_type, section_type).upper(),
        font_size=12, color=color, bold=True,
    )

    # Date
    add_textbox(
        slide,
        left=Inches(0.8), top=Inches(0.8),
        width=Inches(3), height=Inches(0.4),
        text=date,
        font_size=12, color=COLOR_TEXT_MUTED,
    )

    # Title text
    title_top = Inches(1.4)
    title_height = Inches(1.6)
    add_textbox(
        slide,
        left=Inches(0.8), top=title_top,
        width=Inches(11.5), height=title_height,
        text=title,
        font_size=32, color=COLOR_TEXT_WHITE, bold=True,
    )

    # Hero image (centered below title)
    if image_stream:
        try:
            img = Image.open(image_stream)
            img_w, img_h = img.size
            image_stream.seek(0)

            # Available area for image
            avail_w = Inches(10)
            avail_h = Inches(4)
            avail_top = Inches(3.2)

            # Scale to fit
            scale_w = avail_w / Emu(int(img_w * 914400 / 96))  # px to EMU at 96 DPI
            scale_h = avail_h / Emu(int(img_h * 914400 / 96))
            scale = min(scale_w, scale_h, 1.0)

            pic_w = int(img_w * 914400 / 96 * scale)
            pic_h = int(img_h * 914400 / 96 * scale)

            # Center horizontally
            left = int((SLIDE_WIDTH - pic_w) / 2)
            top = int(avail_top)

            slide.shapes.add_picture(image_stream, left, top, pic_w, pic_h)
        except Exception as e:
            print(f"  ‚ö† Could not add image to slide: {e}")
    else:
        # No image ‚Äî use fallback image based on section type
        fallback_path = FALLBACK_IMAGES.get(section_type)
        if fallback_path and fallback_path.exists():
            try:
                fb_stream = io.BytesIO(fallback_path.read_bytes())
                img = Image.open(fb_stream)
                img_w, img_h = img.size
                fb_stream.seek(0)

                avail_w = Inches(10)
                avail_h = Inches(4)
                avail_top = Inches(3.2)

                scale_w = avail_w / Emu(int(img_w * 914400 / 96))
                scale_h = avail_h / Emu(int(img_h * 914400 / 96))
                scale = min(scale_w, scale_h, 1.0)

                pic_w = int(img_w * 914400 / 96 * scale)
                pic_h = int(img_h * 914400 / 96 * scale)

                left = int((SLIDE_WIDTH - pic_w) / 2)
                top = int(avail_top)

                slide.shapes.add_picture(fb_stream, left, top, pic_w, pic_h)
            except Exception as e:
                print(f"  ‚ö† Could not add fallback image: {e}")
        else:
            add_textbox(
                slide,
                left=Inches(1), top=Inches(4),
                width=Inches(11.333), height=Inches(1),
                text="(No image available)",
                font_size=16, color=COLOR_TEXT_MUTED,
                alignment=PP_ALIGN.CENTER,
            )


def create_article_summary_slide(prs: Presentation, title: str, summary: str,
                                  speaker_notes: str, article_url: str,
                                  section_type: str):
    """Create slide 2 for an article: summary + speaker notes."""
    slide = prs.slides.add_slide(prs.slide_layouts[6])
    set_slide_bg(slide, COLOR_BG_DARK)

    color = SECTION_COLORS.get(section_type, COLOR_ACCENT)

    # Title (smaller, as reference)
    add_textbox(
        slide,
        left=Inches(0.8), top=Inches(0.4),
        width=Inches(11.5), height=Inches(0.8),
        text=title,
        font_size=22, color=color, bold=True,
    )

    # Summary text
    txBox = slide.shapes.add_textbox(
        Inches(0.8), Inches(1.5), Inches(11.5), Inches(4.5)
    )
    tf = txBox.text_frame
    tf.word_wrap = True

    # Split summary into paragraphs for readability
    paragraphs = [p.strip() for p in summary.split("\n") if p.strip()]
    for i, para_text in enumerate(paragraphs):
        if i == 0:
            p = tf.paragraphs[0]
        else:
            p = tf.add_paragraph()
        p.text = para_text
        p.font.size = Pt(18)
        p.font.color.rgb = COLOR_TEXT_LIGHT
        p.font.name = "Segoe UI"
        p.space_after = Pt(12)

    # Article link at bottom
    if article_url:
        add_textbox(
            slide,
            left=Inches(0.8), top=Inches(6.5),
            width=Inches(11.5), height=Inches(0.5),
            text=f"üîó {article_url}",
            font_size=11, color=COLOR_TEXT_MUTED,
        )

    # Speaker notes
    if speaker_notes:
        notes_slide = slide.notes_slide
        notes_slide.notes_text_frame.text = speaker_notes


# ---------------------------------------------------------------------------
# File discovery and processing
# ---------------------------------------------------------------------------

def discover_articles(output_dir: Path) -> dict[str, list[dict]]:
    """Find all markdown files and group them by type."""
    type_dirs = {
        "new-release": "new-releases",
        "improvement": "improvements",
        "deprecation": "deprecations",
    }

    articles_by_type: dict[str, list[dict]] = {
        "new-release": [],
        "improvement": [],
        "deprecation": [],
    }

    for article_type, dir_name in type_dirs.items():
        dir_path = output_dir / dir_name
        if not dir_path.is_dir():
            continue

        for md_file in sorted(dir_path.glob("*.md")):
            text = md_file.read_text(encoding="utf-8")
            fm, body = parse_front_matter(text)

            # Resolve the type from front matter or directory
            fm_type = fm.get("type", article_type)
            # Normalize type names
            if fm_type in ("new-releases", "new-release", "release"):
                fm_type = "new-release"
            elif fm_type in ("improvements", "improvement"):
                fm_type = "improvement"
            elif fm_type in ("deprecations", "deprecation", "retired"):
                fm_type = "deprecation"

            articles_by_type.setdefault(fm_type, []).append({
                "title": fm.get("title", md_file.stem),
                "date": fm.get("date", ""),
                "type": fm_type,
                "image_url": extract_image_url(body, fm),
                "article_url": fm.get("article_url", ""),
                "summary": extract_summary(body),
                "speaker_notes": extract_speaker_notes(body),
                "file": str(md_file),
            })

    return articles_by_type


def build_presentation(articles_by_type: dict[str, list[dict]],
                       start_date: str, end_date: str,
                       output_path: str):
    """Build the complete PowerPoint presentation."""
    prs = Presentation()

    # Set widescreen 16:9
    prs.slide_width = SLIDE_WIDTH
    prs.slide_height = SLIDE_HEIGHT

    # Title slide
    create_title_slide(prs, start_date, end_date)

    total = sum(len(v) for v in articles_by_type.values())
    processed = 0

    # Process each type section
    for section_type in ("new-release", "improvement", "deprecation"):
        articles = articles_by_type.get(section_type, [])
        if not articles:
            continue

        # Section divider
        create_section_slide(prs, section_type, len(articles))

        # Sort articles by date
        articles.sort(key=lambda a: a.get("date", ""))

        for article in articles:
            processed += 1
            title = article["title"]
            print(f"  [{processed}/{total}] {title}")

            # Download image
            img_stream = download_image(article["image_url"])

            # Slide 1: Title + Image
            create_article_title_slide(
                prs, title, article["date"], section_type, img_stream
            )

            # Slide 2: Summary + Speaker Notes
            create_article_summary_slide(
                prs, title, article["summary"],
                article["speaker_notes"], article["article_url"],
                section_type,
            )

    prs.save(output_path)
    print(f"\n‚úÖ Presentation saved to: {output_path}")
    print(f"   Total slides: {len(prs.slides)}")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def detect_date_range(output_dir: Path) -> tuple[str, str]:
    """Try to detect date range from the index.md or article files."""
    index_file = output_dir / "index.md"
    if index_file.exists():
        text = index_file.read_text(encoding="utf-8")
        match = re.search(r"(\d{4}-\d{2}-\d{2})\s*[-‚Äì‚Äî]\s*(\d{4}-\d{2}-\d{2})", text)
        if match:
            return match.group(1), match.group(2)

    # Fallback: scan all article dates
    dates = []
    for md_file in output_dir.rglob("*.md"):
        if md_file.name == "index.md":
            continue
        text = md_file.read_text(encoding="utf-8")
        fm, _ = parse_front_matter(text)
        d = fm.get("date", "")
        if d:
            dates.append(str(d))

    if dates:
        dates.sort()
        return dates[0], dates[-1]

    return "unknown", "unknown"


def main():
    parser = argparse.ArgumentParser(
        description="Convert Copilot changelog markdown files to PowerPoint"
    )
    parser.add_argument(
        "--output-dir", "-d",
        default="output",
        help="Directory containing the markdown files (default: output/)",
    )
    parser.add_argument(
        "--output", "-o",
        default="",
        help="Output .pptx filename (default: copilot-updates-{dates}.pptx)",
    )
    parser.add_argument(
        "--from-date",
        default="",
        help="Start date for the title slide (auto-detected if not set)",
    )
    parser.add_argument(
        "--to-date",
        default="",
        help="End date for the title slide (auto-detected if not set)",
    )
    args = parser.parse_args()

    output_dir = Path(args.output_dir)
    if not output_dir.is_dir():
        print(f"‚ùå Output directory not found: {output_dir}")
        print("   Run the Copilot agent first to generate markdown files.")
        sys.exit(1)

    print("üìÇ Scanning for articles...")
    articles_by_type = discover_articles(output_dir)

    total = sum(len(v) for v in articles_by_type.values())
    if total == 0:
        print("‚ùå No articles found in the output directory.")
        print("   Make sure the Copilot agent has generated .md files in:")
        print(f"   {output_dir}/new-releases/")
        print(f"   {output_dir}/improvements/")
        print(f"   {output_dir}/deprecations/")
        sys.exit(1)

    for section_type, articles in articles_by_type.items():
        if articles:
            label = SECTION_TITLES.get(section_type, section_type)
            print(f"   {label}: {len(articles)} articles")

    # Date range
    start_date = args.from_date
    end_date = args.to_date
    if not start_date or not end_date:
        detected_start, detected_end = detect_date_range(output_dir)
        start_date = start_date or detected_start
        end_date = end_date or detected_end

    # Output filename
    output_path = args.output
    if not output_path:
        output_path = f"copilot-updates-{start_date}-to-{end_date}.pptx"

    print(f"\nüî® Building presentation ({start_date} ‚Üí {end_date})...")
    build_presentation(articles_by_type, start_date, end_date, output_path)


if __name__ == "__main__":
    main()
